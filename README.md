## Otel Astronomy Shop Demo App


What is Open Telemetry (OTel)?
OpenTelemetry is an open-source project designed to provide a unified standard for collecting and managing telemetry data from software applications, including traces, metrics, and logs. It helps in observing and understanding the behavior of applications and systems by offering a set of APIs, libraries, and agents for instrumenting code and exporting telemetry data.


<img width="459" alt="image" src="https://github.com/user-attachments/assets/ef852415-6a81-4732-a368-2774ba044a38" />


Architecture Diagram

<img width="435" alt="image" src="https://github.com/user-attachments/assets/0a4042ef-db8e-41fc-8547-852368bee19a" />



## Prerequisites:
1. AWS Cloud

# Steps:

Create EC2 instance with the following configurations: 	
- Ubuntu 22
- T2.xlarge (More than 6GB ram required)
- 15GB storage

<img width="287" alt="image" src="https://github.com/user-attachments/assets/56fcc5a3-2917-4bce-b57e-381f22fc83f6" />





Clone the repo:

<img width="468" alt="image" src="https://github.com/user-attachments/assets/542c6dee-422f-4df4-93e4-9cd61d3e5c36" />
<img width="468" alt="image" src="https://github.com/user-attachments/assets/d28f6542-b12e-438c-94d6-820ced1b42eb" />


As a DevOps Engineer you should understand what this project is doing and how things are happening so letʼs understand the docker compose file responsible for deploying the app.

## Understanding the docker compose file structure!

This Docker Compose file is designed to set up an observability demo
environment using various microservices. If you're new to observability, here's how you can understand this setup:
https://github.com/open-telemetry/opentelemetry-demo/blob/main/docker- compose.yml

# Breakdown of the File:
- # Logging Configuration ( x-default-logging):
  This section defines how logs are handled. The logs are stored in JSON format with    limits on file size (5m) and number of files (2). The <img width="21" alt="image" src="https://github.com/user-attachments/assets/6cee0de3-fe12-4257-ac6a-5102bf04985f" /> option adds a name tag to each log entry, which is useful for identifying which       service generated the log.
  
 - # Networks:
  The	networks section defines a custom network called <img width="96" alt="image" src="https://github.com/user-attachments/assets/1ca7ab7f-bbbf-42ed-9c22-5d3b505d6638" /> using the bridge driver, which allows containers to communicate with each other.
	
- # Services:
  Each service represents a different microservice in the application. These microservices work together to form a complete application.

# Service Details:

<img width="453" alt="image" src="https://github.com/user-attachments/assets/20c703dc-0ab6-4970-9f4a-7dcf7c8023b3" />

Microservices in the app and the languages they are written in.

1.** Core Demo Services: Application services written in different languages.

2.** Dependent Services: Services that the application services depend on like Redis, Kafka etc.

3.** Telemetry Components: Components that deal with the telemetry data generated by the above services like Collector, Prometheus, Grafana, OpenSearch, Jaeger.

- # Accounting Service (accountingservice):
  - ** Image: Specifies the Docker image used to run the service.
    
  - ** Build: Defines how the service is built, including the Dockerfile to use.
    
  - ** Environment Variables: Configures how the service interacts with other parts of the system, like setting the endpoint for sending telemetry data to
an OpenTelemetry collector (	).
Dependencies:	ensures certain services like
(OpenTelemetry Collector) and	are started before this service.
Logging: Uses the predefined logging configuration.
Ad Service (	):

Similar to the accounting service but with additional ports exposed and configured for sending logs and metrics to the observability system.
Cart Service (	):
Handles shopping cart operations and interacts with other services like
, all while sending telemetry data to OpenTelemetry.
Checkout Service (	):
Manages the checkout process. It depends on multiple other services to ensure the whole checkout flow works properly. It also sends data for observability.

Other Services (e.g.,

,

,	):

Each of these services plays a specific role in the application (like handling currency conversion, sending emails, or detecting fraud) and is configured similarly with dependencies, logging, and observability settings.
Frontend (	) and Frontend Proxy (	):


The

services.

service is the user-facing part of the application, while helps manage traffic between the frontend and backend

Image Provider (
 The

) and Load Generator (	): supplies images to the frontend, and the

simulates user traffic to test the system'ssrc/flagd/demo.flagd.json performance.


Observability in Action:
	Telemetry Data: Most services are configured to send data (logs, metrics, and

traces) to an OpenTelemetry Collector ( this data, making it available for analysis.

), which collects and processes

Dependencies: The	condition ensures that services are started in
the right order, crucial for a distributed system to function properly.

We can also check how the OTEL variables are being passed as environment variables for the core demo and dependent services. The config files and the
code for all these are in the	folder. You can go ahead and look at how each
service is instrumented considering the language and this documentation here helps us to better understand the instrumentation for each service in detail.


Otel Collector



Receivers: Collect telemetry data (traces, metrics, logs) from various sources (e.g., applications, services, or endpoints).
Exporters: Send the collected telemetry data to external systems or storage (e.g., logging systems, metrics platforms).
Processors: Transform or modify the telemetry data between collection and export (e.g., batch processing, filtering, or data enrichment).
Connectors (spanmetrics): Extracts metrics from trace data (span metrics) for further processing or export.
Service: Defines how telemetry data flows through the system, specifying which receivers, processors, and exporters are used for traces, metrics, and logs.




otelcol-config.yaml file explained!
This file is a configuration for an OpenTelemetry Collector, which is used to
collect, process, and export telemetry data (traces, metrics, logs) from various sources. Below is a breakdown of each section:
1.Receivers

The OpenTelemetry Protocol (OTLP) receiver is configured to accept

telemetry data over

and

. The endpoint values are determined by

environment variables

,

, and

. The HTTP or HTTPS origin.

configuration allows requests from any


 


This receiver checks the availability of the HTTP requests to the endpoint

service by sending
.


 
This receiver collects metrics related to Docker containers by connecting
to Docker through the UNIX socket	.

This receiver collects metrics from a Redis instance running at the

endpoint
collects data every

, authenticating with the username
.

. It


 
This receiver gathers various host-level metrics, such as CPU, disk, load, filesystem, memory, network, paging, and processes. Some metrics are filtered based on mount points and filesystem types.

This receiver scrapes metrics from the OpenTelemetry Collector itself
using Prometheus. It scrapes every	from the target	.

2.Exporters

This exporter is likely used for debugging purposes, exporting data to a local or testing environment.



Exports traces to a Jaeger instance running at

with

but

marked as	, meaning it doesnʼt enforce strict certificate checks.

Exports metrics to Prometheus using the OTLP over HTTP at the endpoint
, also marked as	.

Exports logs to an OpenSearch instance at	. Logs are
stored in an index named	.

3.Processors

This processor batches data before exporting it, which helps in reducing the number of requests sent to the exporters.

This processor modifies trace data. It contains statements to replace certain parts of trace span names, such as removing query parameters

(

) and standardizing API endpoint names (e.g.,
).

4.Connectors

This connector is used to extract metrics from trace data, allowing for metrics such as request latency to be derived from traces.
5.Service

 
Defines the pipelines for processing and exporting telemetry data:



Receivers: [otlp]
Processors: [transform, batch] Exporters: [otlp, debug, spanmetrics]
This pipeline handles trace data, processes it with the





and

processors, and exports it using the exporters.

,

, and


 
Receivers: [hostmetrics, docker_stats, httpcheck/frontendproxy, otlp, prometheus, redis, spanmetrics]
Processors: [batch]
Exporters: [otlphttp/prometheus, debug]
This pipeline handles metrics, processes them with the
processor, and exports them to Prometheus and the debug endpoint.



Receivers: [otlp] Processors: [batch]
Exporters: [opensearch, debug]
This pipeline handles log data, processes it with the
and exports it to OpenSearch and the debug endpoint.

Summary






processor,

This file configures an OpenTelemetry Collector to gather telemetry data from various sources, process it, and export it to different backends like Jaeger, Prometheus, and OpenSearch. Each pipeline is responsible for a specific type of telemetry data (traces, metrics, logs), ensuring that the data is collected, processed, and exported according to the defined configuration.

Now that you understood everything, lets start with deploying the application and then OBSERVE it!


Install Docker





















Now start the application:





•After a while all your containers should have been created and started.





































Once all the containers are started, we can see the access them: 	Web store: http://IP:8080/
	Grafana: http://IP:8080/grafana/

Load Generator UI: http://IP:8080/loadgen/ Jaeger UI: http://IP:8080/jaeger/ui/

Feature Flags
The demo provides several feature flags that you can use to simulate different scenarios.

https://opentelemetry.io/docs/demo/feature-flags/


Flag values are stored in the	file. To enable a flag, change
the	value in the config file for a given flag to “onˮ.



View and Analyse with the Jaeger UI
With the	feature flag enabled, letʼs see how we can use Jaeger to
diagnose the issue to determine the root cause. Remember, that the service will generate an error for GetAds 1/10th of the time.

Jaeger is usually the first tool you get in contact with when you start getting into the world of Distributed Tracing. With Jaeger, we can visualise the whole chain of events. With this visibility we can easier isolate the problem when something goes
wrong.













Metrics on Grafana






By following these steps, you can set up and explore an observability demo environment using OpenTelemetry and Docker. This setup will help you
understand the intricacies of distributed tracing and how to monitor and diagnose issues in microservices-based applications.
